{
  "hash": "a867dbc29762a75bbf20c3c1aab8ebd2",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Can You Predict That? Predicting Home Prices with Machine Learning\"\nauthor: \"Luis Rivera\"\nformat:\n  html:\n    self-contained: false\n    page-layout: full\n    title-block-banner: true\n    toc: true\n    toc-depth: 3\n    toc-location: body\n    number-sections: false\n    html-math-method: katex\n    code-fold: true\n    code-summary: \"Show the code\"\n    code-overflow: wrap\n    code-copy: hover\n    code-tools:\n        source: false\n        toggle: true\n        caption: See code\nexecute: \n  warning: false\n    \n---\n\n::: {#f5ccdfb7 .cell execution_count=1}\n``` {.python .cell-code}\nimport json\nimport geopandas as gpd\nimport pandas as pd\nimport numpy as np\nimport folium\nfrom folium.plugins import DualMap\n# libraries for machine learning model and folium map\nfrom sklearn.model_selection import train_test_split\n# from sklearn.preprocessing import OneHotEncoder\nfrom xgboost import XGBRegressor\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score\nfrom folium.features import GeoJson, GeoJsonTooltip\n```\n:::\n\n\n## Home Prices in Texas\n\n__What is the average home price by Zipcode in Texas?__\n\n__\n\n::: {#4d0d46c5 .cell execution_count=2}\n``` {.python .cell-code}\n# Here I am reading in my data\ndf = pd.read_csv(\"./ml_datasets/US Homes Data (For Sale Properties).csv\")\n\n# I filter to only keep data from the state of Texas, specifically for homes that are for sale\ndf = df[(df[\"state\"].isin([\"TX\"])) & (df[\"property_status\"].isin([\"FOR_SALE\"])) & (~df[\"living_space\"].isin([0,1,2,3]))]\n\n# I only look at apartments, condo, manufactured, multi_family, single_family, and townhouse homes\ndf = df[~df['property_type'].isin(['LOT'])]\n\n# I filter out the rows with negative landscape values\ndf = df[~df['land_space'].isin([-10890.0])]\n\n# Here I change acres to square feet in the land_space column\ndf['land_space'] = round(df.apply(lambda row: row['land_space'] * 43560 if row['land_space_unit'] == 'acres' else row['land_space'], axis=1),2)\n\n# Here I make the price_per_unit column more accurate\ndf['price_per_unit'] = round(df['price'] / df['living_space'], 2)\ndf['price_per_unit'] = df.apply(lambda row: round(row['price'] / row['living_space'], 2) if (row['living_space'] > 0) and not pd.isna(row['living_space']) else row['price_per_unit'], axis=1)\n\n# Here I drop the extra columns that I do not need, and can drop now\ndf = df.drop(['property_url','property_id', 'address', 'street_name', 'apartment', 'city', 'state','land_space_unit', 'broker_id', 'property_status',\n              'year_build', 'total_num_units' , 'listing_age', 'RunDate', 'agency_name', 'agent_name', 'agent_phone', 'latitude', 'longitude',\n              'price_per_unit'], axis=1).reset_index(drop=True)\n\n# One-hot encoding\ndf = pd.get_dummies(df, columns=['property_type'], dtype='int')\n\n# Here I change the name of my postcode column to zip_code\ndf.rename(columns={'postcode': 'zip_code'}, inplace=True)\n```\n:::\n\n\n::: {#dc7a6578 .cell execution_count=3}\n``` {.python .cell-code}\n# Machine learning preparation.\n# Turning the city column to a categorical type\n# This is important for XGBoost to handle the data correctly\n# df['city'] = df['city'].astype('category')\n# ml_df = df.copy()\n\n# Load the GeoJSON shape file for Texas ZIP codes\nurl = \"https://raw.githubusercontent.com/OpenDataDE/State-zip-code-GeoJSON/refs/heads/master/tx_texas_zip_codes_geo.min.json\"\nzip_shapes = gpd.read_file(url)\n\n# Make sure ZIP codes are strings (important for matching)\ndf['zip_code'] = df['zip_code'].astype(str)\nzip_shapes['ZCTA5CE10'] = zip_shapes['ZCTA5CE10'].astype(str)\n\n# Here I do a left join (everything from the ml_df and only matching rows from zip_shapes)\nnew_df = pd.merge(df,zip_shapes, left_on='zip_code', right_on='ZCTA5CE10', how='left')\n\n# Here I drop the extra columns that I do not need\nml_clean = new_df.drop(['STATEFP10', 'ZCTA5CE10', 'GEOID10','CLASSFP10', 'MTFCC10', 'FUNCSTAT10', 'ALAND10',\n                          'AWATER10', 'INTPTLAT10', 'INTPTLON10', 'PARTFLG10'], axis=1)\n\n# Tell GeoPandas which column holds the geometry\nml_clean = gpd.GeoDataFrame(ml_clean, geometry='geometry')\n\n# Check the current coordinate reference system (CRS)\n# print(ml_clean.crs)\n\n# Now I can safely extract spatial features\n\n# Extract spatial features\n# Calculate centroid coordinates in meters\nml_clean['zip_centroid_lon'] = ml_clean.geometry.centroid.x\nml_clean['zip_centroid_lat'] = ml_clean.geometry.centroid.y\n\n# Here I drop the geometry column (not needed for modeling) and city column (one-hot encoding and label encoding are not ideal for this column)\nml_clean = ml_clean.drop(columns=['geometry'])\n```\n:::\n\n\n::: {#1519eb7b .cell execution_count=4}\n``` {.python .cell-code}\n# Drop zipcode for model training\nX = ml_clean.drop(columns=['price'])\ny = ml_clean['price']\n\n# Here I make the target variable a log to improve my machine learning model performance\ny = np.log1p(y)\n\nX_train_full, X_test_full, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Here I save the zipcodes separately before I drop them for modeling\n\n# Zipcodes aligned to my training set\nzip_train = X_train_full['zip_code'].reset_index(drop=True)\n\n# Zipcodes aligned to my test set\nzip_test = X_test_full['zip_code'].reset_index(drop=True)\n\n# Here I remove the zipcodes from the actual training data\nX_train = X_train_full.drop(columns=['zip_code'])\nX_test = X_test_full.drop(columns=['zip_code'])\n\n# create model instance\nxgb = XGBRegressor(n_estimators=350, max_depth=10, learning_rate=.01, random_state=42)\n# fit model\nxgb.fit(X_train, y_train)\n# make predictions\ny_pred = xgb.predict(X_test)\n\nprint(\"Mean Absolute Error (MAE):\", mean_absolute_error(y_test, y_pred))\nprint(\"Mean Squared Error (MSE):\", mean_squared_error(y_test, y_pred))\nrmse = np.sqrt(mean_squared_error(y_test, y_pred))\nprint(\"Root Mean Squared Error (RMSE):\", rmse)\nprint(\"R² Score:\", r2_score(y_test, y_pred))\n\n# # undo the log1p transformation to get the actual price predictions\n# y_pred = np.expm1(y_pred)\n# y_test = np.expm1(y_test)\n\nresults = pd.DataFrame({\n    'zip_code': zip_test,\n    'prediction': y_pred,\n    'actual_price': y_test.reset_index(drop=True)\n})\n\n# results\n\n# Here I group by zip_code column and calculate the mean of the prediction and actual values\nresults = results.groupby('zip_code')[['prediction', 'actual_price']].mean()\n\n# Round to two decimal places\nresults['actual_price'] = results['actual_price'].round(2)\n\n# Here I change the name of my predicition column and actual price column\nresults = results.rename(columns={'prediction': 'average_price_prediction_log', 'actual_price': 'actual_average_price_log'})\n\nresults = pd.DataFrame(results).reset_index()\n\n# undo the log1p transformation to get the actual price predictions in different columns\nresults['average_price_prediction'] = np.expm1(results['average_price_prediction_log'])\nresults['actual_average_price'] = np.expm1(results['actual_average_price_log'])\n\n\n# Here I do a left join (everything from the ml_df and only matching rows from zip_shapes)\nresults = pd.merge(results,zip_shapes, left_on='zip_code', right_on='ZCTA5CE10', how='left')\n\n# Here I drop the extra columns that I do not need\nresults = results.drop(['STATEFP10', 'ZCTA5CE10', 'GEOID10','CLASSFP10', 'MTFCC10', 'FUNCSTAT10', 'ALAND10',\n                          'AWATER10', 'INTPTLAT10', 'INTPTLON10', 'PARTFLG10'], axis=1)\n\n# Tell GeoPandas which column holds the geometry\nresults = gpd.GeoDataFrame(results, geometry='geometry')\n\n# results\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMean Absolute Error (MAE): 0.22063838742237502\nMean Squared Error (MSE): 0.1207861593836633\nRoot Mean Squared Error (RMSE): 0.34754303241996276\nR² Score: 0.8472178918654716\n```\n:::\n:::\n\n\n::: {#fbe5a336 .cell execution_count=5}\n``` {.python .cell-code}\n# The actual heat map\n# geojson_data = tacos.__geo_interface__  # convert GeoDataFrame to GeoJSON\n# Create a map centered over Texas\nm1 = folium.Map(location=[31.9686, -99.9018], zoom_start=6.35, tiles='OpenStreetMap', width=\"42%\", height=\"70%\")\n\n# Add the choropleth (color-coded layer)\nfolium.Choropleth(\n    # This is the GeoJSON data that contains the shapes of the ZIP code areas.\n    geo_data=results,\n    # This is the data that I want to visualize.\n    data=results,\n    # Here I specify what columns to use (the column that ties to the geographic shapes and the column with the data to visualize).\n    # The first column is the ZIP code, and the second column is the average price.\n    columns=['zip_code', 'average_price_prediction_log'],\n    # The key_on value should be a string that represents the path in the GeoJSON structure to the property (key) that holds the value you want to match with the data DataFrame.\n    key_on='feature.properties.zip_code',\n    # This sets the color scale used to fill each area.\n    fill_color='plasma',\n    # This sets the transparency of the filled areas.\n    fill_opacity=0.7,\n    # This sets the transparency of the boundary lines between the geographic shapes.\n    line_opacity=0.45,\n    legend_name= 'Average Price Prediction (Log Scale - Smallest to Largest)',\n    # Here I set the color of the legend text to white\n    # This is important for the dark background map style.\n).add_to(m1)\n\ntooltip = GeoJson(\n    results,\n    style_function=lambda x: {\n        # Don't add a fill color (we're already coloring with the choropleth)\n        'fillColor': 'transparent',\n        # Hide the border line color\n        'color': 'transparent',\n        # No border line thickness\n        'weight': 0\n    },\n    tooltip=GeoJsonTooltip(\n        # Columns to display in the tooltip\n        fields=['zip_code', 'average_price_prediction'],\n        # What to display as labels for the fields (instead of the column names)\n        aliases=['ZIP Code:', 'Average Price Prediction:'],\n        # Formats numbers using local formatting (e.g. commas in large numbers)\n        localize=True,\n        # Tooltip \"sticks\" to your mouse as you move around that shape. Nice UX\n        sticky=True,\n        # Shows the field names (the aliases you defined).\n        labels=True\n    )\n).add_to(m1)\n\nm1.save(\"folium_map.html\")\n\n```\n:::\n\n\n:::{.column width=\"100%\"}\n\n<iframe src=\"folium_map.html\" width=\"100%\" height=\"700\" style=\"border:none;\"></iframe>\n\n:::\n\n::: {#90bfcce6 .cell execution_count=6}\n``` {.python .cell-code}\n# m2 = folium.Map(location=[31.9686, -99.9018], zoom_start=6.35, tiles='OpenStreetMap', width=\"42%\", height=\"70%\")\n# # Add the choropleth (color-coded layer)\n# folium.Choropleth(\n#     # This is the GeoJSON data that contains the shapes of the ZIP code areas.\n#     geo_data=results,\n#     # This is the data that I want to visualize.\n#     data=results,\n#     # Here I specify what columns to use (the column that ties to the geographic shapes and the column with the data to visualize).\n#     # The first column is the ZIP code, and the second column is the average price.\n#     columns=['zip_code', 'actual_average_price_log'],\n#     # The key_on value should be a string that represents the path in the GeoJSON structure to the property (key) that holds the value you want to match with the data DataFrame.\n#     key_on='feature.properties.zip_code',\n#     # This sets the color scale used to fill each area.\n#     fill_color='plasma',\n#     # This sets the transparency of the filled areas.\n#     fill_opacity=0.7,\n#     # This sets the transparency of the boundary lines between the geographic shapes.\n#     line_opacity=0.45,\n#     legend_name= 'Actual Average Price (Log Scale - Smallest to Largest)',\n#     # Here I set the color of the legend text to white\n#     # This is important for the dark background map style.\n# ).add_to(m2)\n\n# tooltip = GeoJson(\n#     results,\n#     style_function=lambda x: {\n#         # Don't add a fill color (we're already coloring with the choropleth)\n#         'fillColor': 'transparent',\n#         # Hide the border line color\n#         'color': 'transparent',\n#         # No border line thickness\n#         'weight': 0\n#     },\n#     tooltip=GeoJsonTooltip(\n#         # Columns to display in the tooltip\n#         fields=['zip_code', 'actual_average_price'],\n#         # What to display as labels for the fields (instead of the column names)\n#         aliases=['ZIP Code:', 'Actual Average Price:'],\n#         # Formats numbers using local formatting (e.g. commas in large numbers)\n#         localize=True,\n#         # Tooltip \"sticks\" to your mouse as you move around that shape. Nice UX\n#         sticky=True,\n#         # Shows the field names (the aliases you defined).\n#         labels=True\n#     )\n# ).add_to(m2)\n\n# m2 \n```\n:::\n\n\n",
    "supporting": [
      "project1_files"
    ],
    "filters": [],
    "includes": {}
  }
}